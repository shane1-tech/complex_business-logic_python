# -*- coding: utf-8 -*-
"""Deterministic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19PoM28VGSf2xffAN_NotbZiZd_oop-fk
"""

import numpy as np
import pandas as pd

def generate_deterministic_data(n_samples=10000):
    np.random.seed(42) # The "Gold Standard" for reproducibility
    data = pd.DataFrame({
        'transaction_id': np.arange(n_samples),
        'amount': np.random.uniform(1, 5000, n_samples),
        'user_age': np.random.randint(18, 80, n_samples),
        'hour_of_day': np.random.randint(0, 24, n_samples),
        'prev_failed_attempts': np.random.poisson(0.5, n_samples)
    })
    return data

"""Step 2: Complex Feature Engineering (The Reasoning Chain)

Here, you use scipy to normalize data and create logic-based labels.
"""

from scipy.stats import yeojohnson

def engineer_features(df):
    # 1. Non-linear transformation of amount
    df['amount_transformed'], _ = yeojohnson(df['amount'])

    # 2. Logic-based Risk Scoring (The "Reasoning" part)
    # Risk is high if: (High Amount AND Night time) OR (Previous failed attempts > 2)
    df['risk_score'] = 0
    df.loc[(df['amount'] > 4000) & (df['hour_of_day'].isin([2, 3, 4])), 'risk_score'] += 2
    df.loc[df['prev_failed_attempts'] > 2, 'risk_score'] += 3

    # 3. Create a binary target based on the score
    df['is_fraud'] = (df['risk_score'] >= 3).astype(int)
    return df

import statsmodels.api as sm

def validate_logic(df):
    X = df[['amount_transformed', 'user_age', 'prev_failed_attempts']]
    X = sm.add_constant(X)
    y = df['is_fraud']
    model = sm.Logit(y, X).fit()
    print(model.summary()) # Shows P-values to validate the "reasoning"

"""Step 4: The Reproducible Model

Finalize with a scikit-learn model that yields the same result every time.
"""

from sklearn.ensemble import RandomForestClassifier

def train_final_model(df):
    X = df[['amount_transformed', 'user_age', 'prev_failed_attempts', 'hour_of_day']]
    y = df['is_fraud']

    clf = RandomForestClassifier(n_estimators=100, random_state=42)
    clf.fit(X, y)

    # Predict for a specific "Check-Sum" record
    check_record = np.array([[2.5, 30, 0, 14]]) # Fixed values
    prob = clf.predict_proba(check_record)[0][1]
    print(f"Deterministic Probability for Check-Record: {prob}")